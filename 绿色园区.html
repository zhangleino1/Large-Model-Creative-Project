<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>绿色园区数字孪生BIM平台</title>

    <!-- 1. Load React & ReactDOM first -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

    <!-- 2. Load Prop-types (Critical dependency for Recharts UMD) -->
    <script src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>

    <!-- 3. Load Recharts (Specific compatible version) -->
    <script src="https://unpkg.com/recharts@2.12.7/umd/Recharts.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #020617;
            /* Slate 950 */
            font-family: 'Rajdhani', 'Noto Sans SC', sans-serif;
            color: #e2e8f0;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 2px;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        .glass-panel-light {
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tech-border {
            position: relative;
        }

        .tech-border::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            border-top: 2px solid #38bdf8;
            border-left: 2px solid #38bdf8;
        }

        .tech-border::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            border-bottom: 2px solid #38bdf8;
            border-right: 2px solid #38bdf8;
        }

        /* Animation for scanning effect */
        @keyframes scan {
            0% {
                top: 0%;
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .scanner-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #0ea5e9, transparent);
            box-shadow: 0 0 15px #0ea5e9;
            animation: scan 3s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            z-index: 0;
            pointer-events: none;
        }

        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .animate-fade-in-right {
            animation: fadeInRight 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #334155;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #3b82f6;
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* Metric Bar Animation */
        @keyframes growWidth {
            from {
                width: 0;
            }
        }

        .animate-grow {
            animation: growWidth 1s ease-out forwards;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- SAFE RECHARTS LOADING ---
        const RechartsLib = window.Recharts || {};
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar, AreaChart, Area, PieChart, Pie, Cell } = RechartsLib;
        const ChartsAvailable = !!(LineChart && AreaChart);

        // --- Data ---

        // Global Park Metrics Structure
        const PARK_METRICS = {
            energy: [
                { label: '可再生能源占比', value: '32%', desc: '太阳能/风能', color: 'bg-yellow-500', w: '32%' },
                { label: '峰谷用电比例', value: '1:2.8', desc: '储能调节优', color: 'bg-blue-500', w: '60%' },
                { label: '分布式系统效率', value: '88%', desc: '光伏/余热', color: 'bg-green-500', w: '88%' },
            ],
            water: [
                { label: '单位产值用水量', value: '4.2', unit: 'm³/万元', color: 'bg-cyan-500', w: '40%' },
                { label: '再生水回用率', value: '45%', desc: '中水/雨水', color: 'bg-blue-400', w: '45%' },
                { label: '管网漏损率', value: '1.8%', desc: '优于国标', color: 'bg-red-400', w: '5%' },
                { label: '雨水收集量', value: '1.2万', unit: 'm³/年', color: 'bg-sky-500', w: '65%' },
            ],
            waste: [
                { label: '生活垃圾回收率', value: '92%', color: 'bg-emerald-500', w: '92%' },
                { label: '固废综合利用', value: '98%', color: 'bg-green-600', w: '98%' },
                { label: '危废合规处置', value: '100%', color: 'bg-purple-500', w: '100%' },
                { label: '人均垃圾产生', value: '0.8', unit: 'kg/天', color: 'bg-orange-400', w: '50%' },
            ],
            eco: [
                { label: '绿化覆盖率', value: '42%', color: 'bg-lime-500', w: '42%' },
                { label: '空气优良天数', value: '94%', desc: 'AQI ≤ 100', color: 'bg-teal-400', w: '94%' },
                { label: '噪声达标区域', value: '99%', color: 'bg-indigo-400', w: '99%' },
            ]
        };

        const generateHourlyData = (multiplier = 1) => {
            const data = [];
            for (let i = 0; i < 24; i++) {
                // Enhanced randomness for more realistic curves
                const base = Math.max(10, (Math.random() * 40 + 30) * multiplier);
                const peak = (i > 8 && i < 18 ? (Math.random() * 20 + 20) * multiplier : 0);
                const val = Math.floor(base + peak);

                data.push({
                    time: `${i}:00`,
                    usage: val,
                    predicted: Math.floor(val * (0.85 + Math.random() * 0.3)), // Fluctuate around actual
                });
            }
            return data;
        };

        const generateStats = (buildingId, floorIndex, isBuildingMode) => {
            const floorTypes = ['办公区', '研发中心', '数据机房', '休闲区', '会议中心'];
            const weathers = ['恒温舒适', '稍热', '干燥', '潮湿'];
            
            // 生成完整的24小时数据
            const generateChartData = (multiplier = 1) => {
                const data = [];
                for (let i = 0; i < 24; i++) {
                    const base = Math.max(15, (Math.random() * 40 + 30) * multiplier);
                    const peak = (i > 8 && i < 18 ? (Math.random() * 25 + 20) * multiplier : 0);
                    const val = Math.floor(base + peak);
                    data.push({
                        time: `${i}:00`,
                        usage: val,
                        predicted: Math.floor(val * (0.85 + Math.random() * 0.3)),
                    });
                }
                return data;
            };

            // Building Mode Data (Aggregated)
            if (isBuildingMode) {
                return {
                    id: `${buildingId}-Total`,
                    name: `${buildingId}栋 - 整体概览`,
                    type: '综合绿色建筑',
                    climate: '智能调节中',
                    temperature: (23.5).toFixed(1),
                    humidity: (45).toFixed(0),
                    currentLoad: (Math.random() * 500 + 800).toFixed(1) + ' kW',
                    chartData: generateChartData(5),

                    // Specific Green Metrics for Building
                    unitEnergy: (Math.random() * 20 + 40).toFixed(1), // kWh/m2
                    carbonIntensity: (Math.random() * 0.2 + 0.3).toFixed(2), // tCO2/m2
                    renewableShare: (Math.random() * 10 + 20).toFixed(0) + '%',
                    status: '正常运行'
                };
            }

            // Single Floor Data
            return {
                id: `${buildingId}-F${floorIndex + 1}`,
                name: `${buildingId}栋 - 第 ${floorIndex + 1} 层`,
                type: floorTypes[floorIndex % floorTypes.length],
                climate: weathers[Math.floor(Math.random() * weathers.length)],
                temperature: (22 + Math.random() * 3).toFixed(1),
                humidity: (40 + Math.random() * 20).toFixed(0),
                currentLoad: (Math.random() * 100).toFixed(1) + ' kW',
                chartData: generateChartData(1),

                // Specific Green Metrics for Floor
                unitEnergy: (Math.random() * 10 + 50).toFixed(1), // Higher for floors
                carbonIntensity: (Math.random() * 0.1 + 0.4).toFixed(2),
                renewableShare: 'N/A', // Floors rely on building
            };
        };

        // --- UI Components ---

        const MetricBar = ({ label, value, unit, desc, color, w }) => (
            <div className="mb-3 last:mb-0 group">
                <div className="flex justify-between items-end mb-1">
                    <span className="text-xs text-slate-400 font-medium tracking-wide">{label}</span>
                    <div className="text-right">
                        <span className="text-sm font-bold text-white font-rajdhani">{value} <span className="text-[10px] text-slate-500 font-normal">{unit}</span></span>
                        {desc && <span className="text-[9px] text-slate-500 block -mt-0.5">{desc}</span>}
                    </div>
                </div>
                <div className="h-1.5 w-full bg-slate-800 rounded-full overflow-hidden">
                    <div className={`h-full ${color} rounded-full animate-grow shadow-[0_0_10px_rgba(0,0,0,0.3)]`} style={{ width: w }}></div>
                </div>
            </div>
        );

        // 1. Header
        const Header = () => (
            <div className="absolute top-0 left-0 w-full p-6 z-10 flex justify-between items-start pointer-events-none bg-gradient-to-b from-slate-950 via-slate-950/80 to-transparent pb-12">
                <div className="flex items-center gap-4 pointer-events-auto">
                    <div className="w-12 h-12 bg-emerald-600 rounded-lg flex items-center justify-center shadow-[0_0_20px_rgba(16,185,129,0.4)] border border-emerald-400/30">
                        <i data-lucide="leaf" className="text-white w-6 h-6"></i>
                    </div>
                    <div>
                        <h1 className="text-3xl font-bold tracking-wider text-white drop-shadow-lg font-rajdhani">GREEN PARK <span className="text-emerald-400">TWIN</span></h1>
                        <p className="text-xs text-emerald-200/60 tracking-[0.25em] uppercase font-medium">绿色园区数字孪生交互平台</p>
                    </div>
                </div>

                <div className="flex gap-10 pointer-events-auto glass-panel px-8 py-3 rounded-xl hidden xl:flex border-t border-white/5 shadow-xl">
                    <div className="flex flex-col items-center">
                        <span className="text-[10px] text-slate-400 uppercase tracking-widest mb-1">碳排放强度</span>
                        <span className="text-xl font-bold text-white font-rajdhani">0.42 <span className="text-xs text-slate-500">tCO₂/万元</span></span>
                    </div>
                    <div className="w-px bg-white/10 h-10"></div>
                    <div className="flex flex-col items-center">
                        <span className="text-[10px] text-slate-400 uppercase tracking-widest mb-1">清洁能源占比</span>
                        <span className="text-xl font-bold text-emerald-400 font-rajdhani">32.5 <span className="text-xs text-emerald-600/70">%</span></span>
                    </div>
                    <div className="w-px bg-white/10 h-10"></div>
                    <div className="flex flex-col items-center">
                        <span className="text-[10px] text-slate-400 uppercase tracking-widest mb-1">生物多样性指数</span>
                        <span className="text-xl font-bold text-cyan-400 font-rajdhani">3.8 <span className="text-xs text-cyan-600/70">Index</span></span>
                    </div>
                </div>
            </div>
        );

        // 2. Sidebar (Dashboard)
        const Sidebar = ({ mode, setMode }) => {
            const [activeTab, setActiveTab] = useState('energy'); // energy, water, waste, eco

            // Generate stable random data for the sidebar chart on mount or tab change
            const sidebarChartData = useMemo(() => generateHourlyData(0.8), [activeTab]);

            const TABS = [
                { id: 'energy', icon: 'zap', label: '能源', color: 'text-yellow-400' },
                { id: 'water', icon: 'droplets', label: '水务', color: 'text-cyan-400' },
                { id: 'waste', icon: 'recycle', label: '固废', color: 'text-purple-400' },
                { id: 'eco', icon: 'sprout', label: '生态', color: 'text-emerald-400' },
            ];

            return (
                <div className="absolute left-6 top-32 w-80 z-10 flex flex-col gap-5 pointer-events-none">

                    {/* Interaction Mode Switch */}
                    <div className="glass-panel p-4 rounded-xl tech-border pointer-events-auto">
                        <div className="flex items-center justify-between text-xs text-slate-400 mb-2 uppercase tracking-wider font-semibold">
                            <span>View Mode</span>
                            <i data-lucide="mouse-pointer-2" size={14} className="text-slate-500"></i>
                        </div>
                        <div className="flex items-center justify-between bg-slate-800/80 p-1.5 rounded-lg border border-slate-700/50">
                            <span className={`text-xs px-2 transition-colors ${mode === 'floor' ? 'text-white font-medium' : 'text-slate-500'}`}>楼层</span>
                            <label className="toggle-switch mx-1 scale-75">
                                <input type="checkbox" checked={mode === 'building'} onChange={(e) => setMode(e.target.checked ? 'building' : 'floor')} />
                                <span className="slider bg-slate-600"></span>
                            </label>
                            <span className={`text-xs px-2 transition-colors ${mode === 'building' ? 'text-white font-medium' : 'text-slate-500'}`}>整栋</span>
                        </div>
                    </div>

                    {/* Dashboard Tabs */}
                    <div className="glass-panel rounded-xl overflow-hidden pointer-events-auto tech-border flex flex-col">
                        <div className="flex bg-slate-900/50 border-b border-white/5">
                            {TABS.map(tab => (
                                <button
                                    key={tab.id}
                                    onClick={() => setActiveTab(tab.id)}
                                    className={`flex-1 py-4 flex flex-col items-center gap-1 transition-all relative ${activeTab === tab.id ? 'bg-slate-800/60' : 'hover:bg-slate-800/30'}`}
                                >
                                    <i data-lucide={tab.icon} size={18} className={`${activeTab === tab.id ? tab.color : 'text-slate-500'} transition-colors`}></i>
                                    <span className={`text-[10px] font-medium ${activeTab === tab.id ? 'text-slate-200' : 'text-slate-500'}`}>{tab.label}</span>
                                    {activeTab === tab.id && <div className="absolute bottom-0 left-0 w-full h-0.5 bg-blue-500 shadow-[0_0_8px_#3b82f6]"></div>}
                                </button>
                            ))}
                        </div>

                        {/* Dashboard Content Area */}
                        <div className="p-5 min-h-[280px]">
                            <h3 className="text-slate-300 font-bold mb-4 text-sm flex items-center gap-2">
                                <span className="w-1 h-4 bg-blue-500 rounded-sm"></span>
                                {TABS.find(t => t.id === activeTab).label}核心指标监测
                            </h3>

                            {/* Render Specific Metrics */}
                            <div className="flex flex-col gap-1">
                                {PARK_METRICS[activeTab].map((m, idx) => (
                                    <MetricBar key={idx} {...m} />
                                ))}
                            </div>

                            {/* Mini Chart Area (Contextual) - Now Dynamic */}
                            <div className="mt-5 pt-4 border-t border-white/5">
                                <p className="text-[10px] text-slate-500 mb-2 uppercase tracking-wide">实时趋势</p>
                                <div className="h-24 w-full opacity-80">
                                    {ChartsAvailable && (
                                        <ResponsiveContainer width="100%" height="100%">
                                            <AreaChart data={sidebarChartData}>
                                                <defs>
                                                    <linearGradient id="chartGrad" x1="0" y1="0" x2="0" y2="1">
                                                        <stop offset="5%" stopColor={activeTab === 'energy' ? '#eab308' : activeTab === 'eco' ? '#10b981' : '#0ea5e9'} stopOpacity={0.5} />
                                                        <stop offset="95%" stopColor={activeTab === 'energy' ? '#eab308' : activeTab === 'eco' ? '#10b981' : '#0ea5e9'} stopOpacity={0} />
                                                    </linearGradient>
                                                </defs>
                                                <Area type="monotone" dataKey="usage" stroke={activeTab === 'energy' ? '#eab308' : activeTab === 'eco' ? '#10b981' : '#0ea5e9'} strokeWidth={2} fill="url(#chartGrad)" />
                                            </AreaChart>
                                        </ResponsiveContainer>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // 3. Detail Modal
        const DetailPanel = ({ data, onClose }) => {
            if (!data) return null;

            return (
                <div className="absolute right-6 top-28 w-[400px] bottom-8 z-20 flex flex-col gap-4 animate-fade-in-right pointer-events-none">
                    <div className="glass-panel flex-1 rounded-xl p-6 relative overflow-hidden flex flex-col tech-border pointer-events-auto bg-slate-900/90">
                        <button onClick={onClose} className="absolute top-5 right-5 text-slate-400 hover:text-white transition-colors z-30 bg-slate-800/50 p-1.5 rounded-lg hover:bg-slate-700 border border-white/5">
                            <i data-lucide="x" size={18}></i>
                        </button>

                        <div className="scanner-line"></div>

                        {/* Title Section */}
                        <div className="mb-6 relative z-10">
                            <div className="flex gap-2 mb-2">
                                <span className="bg-blue-500/20 text-blue-300 px-2 py-0.5 rounded text-[10px] border border-blue-500/30 font-bold uppercase tracking-wider">BIM Object</span>
                                <span className="bg-emerald-500/20 text-emerald-300 px-2 py-0.5 rounded text-[10px] border border-emerald-500/30 font-bold uppercase tracking-wider">Green Certified</span>
                            </div>
                            <h2 className="text-2xl font-bold text-white mb-1 font-rajdhani tracking-wide">{data.name}</h2>
                            <p className="text-slate-400 text-xs font-mono">ID: {data.id} | {data.type}</p>
                        </div>

                        {/* Key Green Metrics Grid (New Addition) */}
                        <div className="mb-6 relative z-10">
                            <h4 className="text-xs text-slate-400 mb-3 uppercase tracking-widest font-bold flex items-center gap-2">
                                <i data-lucide="target" size={14} className="text-emerald-400"></i> 关键效能指标
                            </h4>
                            <div className="grid grid-cols-2 gap-3">
                                <div className="glass-panel-light p-3 rounded-lg flex flex-col justify-between h-20 relative overflow-hidden group">
                                    <div className="absolute right-0 top-0 w-16 h-16 bg-blue-500/10 rounded-bl-full -mr-4 -mt-4 transition-all group-hover:bg-blue-500/20"></div>
                                    <span className="text-[10px] text-slate-400 z-10">单位面积能耗</span>
                                    <span className="text-xl font-bold text-white z-10 font-rajdhani">{data.unitEnergy} <span className="text-[10px] text-slate-500">kWh/m²</span></span>
                                </div>
                                <div className="glass-panel-light p-3 rounded-lg flex flex-col justify-between h-20 relative overflow-hidden group">
                                    <div className="absolute right-0 top-0 w-16 h-16 bg-purple-500/10 rounded-bl-full -mr-4 -mt-4 transition-all group-hover:bg-purple-500/20"></div>
                                    <span className="text-[10px] text-slate-400 z-10">碳排放强度</span>
                                    <span className="text-xl font-bold text-white z-10 font-rajdhani">{data.carbonIntensity} <span className="text-[10px] text-slate-500">tCO₂</span></span>
                                </div>
                            </div>
                        </div>

                        {/* Environment & Load */}
                        <div className="grid grid-cols-3 gap-2 mb-6 relative z-10">
                            <div className="bg-slate-800/30 p-2 rounded border border-white/5 text-center">
                                <div className="text-[10px] text-slate-500 mb-1">温度</div>
                                <div className="text-white font-rajdhani font-bold">{data.temperature}°</div>
                            </div>
                            <div className="bg-slate-800/30 p-2 rounded border border-white/5 text-center">
                                <div className="text-[10px] text-slate-500 mb-1">湿度</div>
                                <div className="text-white font-rajdhani font-bold">{data.humidity}%</div>
                            </div>
                            <div className="bg-slate-800/30 p-2 rounded border border-white/5 text-center">
                                <div className="text-[10px] text-slate-500 mb-1">实时负荷</div>
                                <div className="text-blue-400 font-rajdhani font-bold text-sm">{data.currentLoad}</div>
                            </div>
                        </div>

                        {/* Charts Area */}
                        <div className="flex-1 min-h-[180px] flex flex-col gap-4 overflow-hidden relative z-10">
                            <div className="flex-1 min-h-0 bg-slate-800/30 rounded-lg p-4 border border-slate-700/30 flex flex-col">
                                <h4 className="text-xs text-slate-300 mb-2 flex items-center justify-between uppercase tracking-wide font-bold">
                                    <span>24h 能耗趋势</span>
                                    <span className="text-[10px] text-slate-500 font-normal">预测算法: LSTM-v2</span>
                                </h4>
                                <div className="flex-1 w-full min-h-0">
                                    {ChartsAvailable && (
                                        <ResponsiveContainer width="100%" height="100%">
                                            <LineChart data={data.chartData}>
                                                <defs>
                                                    <linearGradient id="lineGrad" x1="0" y1="0" x2="1" y2="0">
                                                        <stop offset="0%" stopColor="#3b82f6" />
                                                        <stop offset="100%" stopColor="#06b6d4" />
                                                    </linearGradient>
                                                </defs>
                                                <CartesianGrid strokeDasharray="3 3" stroke="#334155" vertical={false} opacity={0.5} />
                                                <XAxis dataKey="time" stroke="#64748b" fontSize={9} tickLine={false} axisLine={false} interval={4} />
                                                <YAxis stroke="#64748b" fontSize={9} tickLine={false} axisLine={false} width={25} />
                                                <Tooltip
                                                    contentStyle={{ backgroundColor: '#0f172a', borderColor: '#334155', color: '#f8fafc', borderRadius: '8px', fontSize: '11px' }}
                                                    cursor={{ stroke: '#38bdf8', strokeWidth: 1, strokeDasharray: '4 4' }}
                                                />
                                                <Line type="monotone" dataKey="usage" stroke="url(#lineGrad)" strokeWidth={2} dot={false} activeDot={{ r: 4, fill: '#fff' }} />
                                                <Line type="monotone" dataKey="predicted" stroke="#94a3b8" strokeDasharray="2 2" strokeWidth={1} dot={false} />
                                            </LineChart>
                                        </ResponsiveContainer>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Main App Component ---
        const App = () => {
            const mountRef = useRef(null);
            const [selectedData, setSelectedData] = useState(null);
            const [mode, setMode] = useState('floor'); // 'floor' or 'building'

            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const floorsRef = useRef([]); // Store all floor meshes
            
            // 新增：相机动画控制
            const isAnimatingRef = useRef(false); // 是否正在播放聚焦动画
            const isSelectedRef = useRef(false); // 是否有选中对象（停止旋转）
            const targetCameraPos = useRef(new THREE.Vector3());
            const targetLookAt = useRef(new THREE.Vector3());
            const currentLookAt = useRef(new THREE.Vector3(0, 10, 0));

            useEffect(() => {
                if (window.lucide) {
                    window.lucide.createIcons();
                }
            }, [selectedData, mode]); // Re-run icons when state changes

            useEffect(() => {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // 1. Scene Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020617);
                scene.fog = new THREE.FogExp2(0x020617, 0.012); // Slightly less fog
                sceneRef.current = scene;

                // 2. Camera
                const camera = new THREE.PerspectiveCamera(45, width / height, 1, 2000);
                camera.position.set(50, 40, 70);
                camera.lookAt(0, 5, 0);
                cameraRef.current = camera;

                // 3. Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // 4. Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xa5f3fc, 1.5);
                dirLight.position.set(30, 60, 20);
                scene.add(dirLight);

                const rimLight = new THREE.SpotLight(0x22d3ee, 5);
                rimLight.position.set(-40, 20, -40);
                rimLight.lookAt(0, 0, 0);
                scene.add(rimLight);

                const ecoLight = new THREE.PointLight(0x10b981, 1.5, 80); // Emerald light for "Green" feel
                ecoLight.position.set(0, 10, 0);
                scene.add(ecoLight);

                // 5. Grid
                const gridHelper = new THREE.GridHelper(200, 80, 0x1e293b, 0x0f172a);
                scene.add(gridHelper);

                // 6. Materials
                const glassMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x64748b,
                    metalness: 0.2,
                    roughness: 0.1,
                    transmission: 0.65,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide,
                });

                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: 0x38bdf8,
                    transparent: true,
                    opacity: 0.25
                });

                // Highlight Materials
                const highlightFloorMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x0ea5e9,
                    emissive: 0x0284c7,
                    emissiveIntensity: 0.8,
                    metalness: 0.3,
                    roughness: 0.1,
                    transmission: 0.2,
                    transparent: true,
                    opacity: 0.9
                });

                const highlightBuildingMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x10b981,        // Emerald for "Green Building" selected
                    emissive: 0x059669,
                    emissiveIntensity: 0.6,
                    metalness: 0.1,
                    roughness: 0.1,
                    transmission: 0.5,
                    transparent: true,
                    opacity: 0.85
                });

                // 7. Generate Buildings
                const generateCity = () => {
                    const buildings = [];
                    // Main Tech Hub
                    buildings.push({ x: 0, z: 0, w: 14, d: 14, floors: 10, id: 'Eco-Hub' });
                    // Scattered
                    const count = 18;
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const radius = 28 + Math.random() * 35;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        buildings.push({
                            x: x, z: z,
                            w: 5 + Math.random() * 7,
                            d: 5 + Math.random() * 7,
                            floors: 3 + Math.floor(Math.random() * 9),
                            id: `B-${i + 1}`
                        });
                    }
                    return buildings;
                };

                const cityLayout = generateCity();

                cityLayout.forEach(b => {
                    const floorHeight = 2.8;
                    const gap = 0.1;

                    for (let i = 0; i < b.floors; i++) {
                        const geometry = new THREE.BoxGeometry(b.w, floorHeight, b.d);
                        const mat = glassMaterial.clone();
                        // Slight teal tint for green park vibe
                        const tint = new THREE.Color(0x64748b).lerp(new THREE.Color(0x10b981), Math.random() * 0.1);
                        mat.color = tint;

                        const mesh = new THREE.Mesh(geometry, mat);
                        const yPos = (i * (floorHeight + gap)) + (floorHeight / 2);
                        mesh.position.set(b.x, yPos, b.z);

                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, edgeMaterial);
                        mesh.add(line);

                        mesh.userData = {
                            isFloor: true,
                            buildingId: b.id,
                            floorIndex: i,
                            originalMaterial: mat,
                            highlightFloorMat: highlightFloorMaterial,
                            highlightBuildingMat: highlightBuildingMaterial
                        };

                        scene.add(mesh);
                        floorsRef.current.push(mesh);
                    }
                });

                // 8. Particles (Green Data)
                const particlesGeo = new THREE.BufferGeometry();
                const particlesCount = 500;
                const posArray = new Float32Array(particlesCount * 3);
                for (let i = 0; i < particlesCount * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 160;
                }
                particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const particlesMat = new THREE.PointsMaterial({
                    size: 0.25,
                    color: 0x34d399, // Emerald 400
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending
                });
                const particlesMesh = new THREE.Points(particlesGeo, particlesMat);
                scene.add(particlesMesh);

                // 9. 创建行走的人物
                const people = [];
                const personMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x38bdf8,
                    emissive: 0x0ea5e9,
                    emissiveIntensity: 0.3
                });
                
                for (let i = 0; i < 25; i++) {
                    const personGroup = new THREE.Group();
                    
                    // 身体 (使用圆柱体代替胶囊，兼容r128版本)
                    const bodyGeo = new THREE.CylinderGeometry(0.25, 0.3, 1.2, 8);
                    const body = new THREE.Mesh(bodyGeo, personMaterial.clone());
                    body.position.y = 0.9;
                    personGroup.add(body);
                    
                    // 头部
                    const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
                    const head = new THREE.Mesh(headGeo, personMaterial.clone());
                    head.position.y = 1.7;
                    personGroup.add(head);
                    
                    // 随机初始位置
                    const startAngle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 50;
                    personGroup.position.set(
                        Math.cos(startAngle) * radius,
                        0,
                        Math.sin(startAngle) * radius
                    );
                    
                    // 存储运动数据
                    personGroup.userData = {
                        speed: 0.02 + Math.random() * 0.03,
                        angle: startAngle,
                        radius: radius,
                        direction: Math.random() > 0.5 ? 1 : -1,
                        // 随机路径类型: circle 或 line
                        pathType: Math.random() > 0.3 ? 'circle' : 'line',
                        lineStart: { x: (Math.random() - 0.5) * 80, z: (Math.random() - 0.5) * 80 },
                        lineEnd: { x: (Math.random() - 0.5) * 80, z: (Math.random() - 0.5) * 80 },
                        lineProgress: Math.random(),
                        lineSpeed: 0.002 + Math.random() * 0.003
                    };
                    
                    scene.add(personGroup);
                    people.push(personGroup);
                }

                // 10. 创建移动的车辆
                const vehicles = [];
                const carColors = [0x3b82f6, 0x10b981, 0xf59e0b, 0xef4444, 0x8b5cf6];
                
                for (let i = 0; i < 12; i++) {
                    const carGroup = new THREE.Group();
                    const carColor = carColors[Math.floor(Math.random() * carColors.length)];
                    
                    const carMaterial = new THREE.MeshPhongMaterial({ 
                        color: carColor,
                        emissive: carColor,
                        emissiveIntensity: 0.2,
                        shininess: 100
                    });
                    
                    // 车身
                    const bodyGeo = new THREE.BoxGeometry(1.8, 0.8, 3.5);
                    const carBody = new THREE.Mesh(bodyGeo, carMaterial);
                    carBody.position.y = 0.6;
                    carGroup.add(carBody);
                    
                    // 车顶
                    const roofGeo = new THREE.BoxGeometry(1.4, 0.6, 2);
                    const roofMat = new THREE.MeshPhongMaterial({ 
                        color: 0x1e293b,
                        transparent: true,
                        opacity: 0.7
                    });
                    const roof = new THREE.Mesh(roofGeo, roofMat);
                    roof.position.y = 1.2;
                    roof.position.z = -0.3;
                    carGroup.add(roof);
                    
                    // 车灯 (前)
                    const lightGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                    const lightMat = new THREE.MeshBasicMaterial({ color: 0xfef3c7 });
                    const frontLightL = new THREE.Mesh(lightGeo, lightMat);
                    frontLightL.position.set(-0.6, 0.5, 1.8);
                    carGroup.add(frontLightL);
                    const frontLightR = new THREE.Mesh(lightGeo, lightMat);
                    frontLightR.position.set(0.6, 0.5, 1.8);
                    carGroup.add(frontLightR);
                    
                    // 车灯 (后 - 红色)
                    const tailLightMat = new THREE.MeshBasicMaterial({ color: 0xef4444 });
                    const tailLightL = new THREE.Mesh(lightGeo, tailLightMat);
                    tailLightL.position.set(-0.6, 0.5, -1.8);
                    carGroup.add(tailLightL);
                    const tailLightR = new THREE.Mesh(lightGeo, tailLightMat);
                    tailLightR.position.set(0.6, 0.5, -1.8);
                    carGroup.add(tailLightR);
                    
                    // 设置车辆路径 (园区道路)
                    const pathRadius = 35 + Math.random() * 40;
                    const startAngle = Math.random() * Math.PI * 2;
                    
                    carGroup.position.set(
                        Math.cos(startAngle) * pathRadius,
                        0.1,
                        Math.sin(startAngle) * pathRadius
                    );
                    
                    carGroup.userData = {
                        speed: 0.003 + Math.random() * 0.004,
                        angle: startAngle,
                        radius: pathRadius,
                        direction: Math.random() > 0.5 ? 1 : -1
                    };
                    
                    scene.add(carGroup);
                    vehicles.push(carGroup);
                }

                // Animation
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    const time = Date.now() * 0.0001;
                    const radius = 90;
                    
                    // 如果有选中对象，停止自动旋转，执行聚焦动画
                    if (isSelectedRef.current) {
                        // 平滑过渡相机位置
                        camera.position.lerp(targetCameraPos.current, 0.05);
                        currentLookAt.current.lerp(targetLookAt.current, 0.05);
                        camera.lookAt(currentLookAt.current);
                    } else {
                        // 正常旋转动画
                        camera.position.x = Math.sin(time) * radius;
                        camera.position.z = Math.cos(time) * radius;
                        camera.lookAt(0, 10, 0);
                        currentLookAt.current.set(0, 10, 0);
                    }

                    // Flowing particles
                    particlesMesh.rotation.y = -time * 0.2;

                    // 更新人物位置
                    people.forEach(person => {
                        const data = person.userData;
                        
                        if (data.pathType === 'circle') {
                            // 圆形路径
                            data.angle += data.speed * data.direction;
                            person.position.x = Math.cos(data.angle) * data.radius;
                            person.position.z = Math.sin(data.angle) * data.radius;
                            // 让人物面向行走方向
                            person.rotation.y = -data.angle + Math.PI / 2 * data.direction;
                        } else {
                            // 直线路径
                            data.lineProgress += data.lineSpeed * data.direction;
                            if (data.lineProgress > 1 || data.lineProgress < 0) {
                                data.direction *= -1;
                                data.lineProgress = Math.max(0, Math.min(1, data.lineProgress));
                            }
                            person.position.x = data.lineStart.x + (data.lineEnd.x - data.lineStart.x) * data.lineProgress;
                            person.position.z = data.lineStart.z + (data.lineEnd.z - data.lineStart.z) * data.lineProgress;
                            // 让人物面向行走方向
                            const dx = data.lineEnd.x - data.lineStart.x;
                            const dz = data.lineEnd.z - data.lineStart.z;
                            person.rotation.y = Math.atan2(dx, dz) + (data.direction < 0 ? Math.PI : 0);
                        }
                        
                        // 模拟走路的上下起伏
                        person.position.y = Math.abs(Math.sin(time * 50 * data.speed * 10)) * 0.1;
                    });

                    // 更新车辆位置
                    vehicles.forEach(car => {
                        const data = car.userData;
                        data.angle += data.speed * data.direction;
                        
                        const newX = Math.cos(data.angle) * data.radius;
                        const newZ = Math.sin(data.angle) * data.radius;
                        
                        // 计算车辆朝向
                        car.rotation.y = -data.angle + Math.PI / 2 * data.direction;
                        
                        car.position.x = newX;
                        car.position.z = newZ;
                    });

                    renderer.render(scene, camera);
                };
                animate();

                // Events
                const handleResize = () => {
                    if (!cameraRef.current || !rendererRef.current) return;
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    cameraRef.current.aspect = w / h;
                    cameraRef.current.updateProjectionMatrix();
                    rendererRef.current.setSize(w, h);
                };

                const onDocumentMouseDown = (event) => {
                    if (event.target.closest('.glass-panel') || event.target.closest('button')) return;
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, cameraRef.current);
                    const intersects = raycaster.intersectObjects(floorsRef.current);

                    if (intersects.length > 0) {
                        const object = intersects[0].object;
                        if (object.userData.isFloor) {
                            handleSelection(object);
                        }
                    } else {
                        handleDeselect();
                    }
                };

                window.addEventListener('resize', handleResize);
                window.addEventListener('pointerdown', onDocumentMouseDown);

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('pointerdown', onDocumentMouseDown);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const handleSelection = (mesh) => {
                // Ensure we read the current mode state properly (React state closure issue)
                // In this structure, we might need a ref to track mode inside the callback if it wasn't recreated
                // But since we use selection logic that depends on `mode`, let's just use the state directly.
                // Note: In strict React+Three integration, we'd use refs for mutable state accessed in callbacks.
                // However, since we re-bind listeners or rely on state updates triggering renders, 
                // we will trust the `mode` variable here is accessed via closure, BUT
                // `onDocumentMouseDown` is defined inside useEffect with [] dep array, so it sees OLD `mode`.
                // FIX: We need a ref for mode.
            };

            // Fix for accessing current mode in event listener
            const modeRef = useRef(mode);
            useEffect(() => { modeRef.current = mode; }, [mode]);

            // Redefine handleSelection to use Ref
            const handleSelectionActual = (mesh) => {
                const isBuildingMode = (modeRef.current === 'building');
                const targetId = mesh.userData.buildingId;

                floorsRef.current.forEach(f => {
                    f.material = f.userData.originalMaterial;
                });

                if (isBuildingMode) {
                    floorsRef.current.forEach(f => {
                        if (f.userData.buildingId === targetId) {
                            f.material = f.userData.highlightBuildingMat;
                        }
                    });
                } else {
                    mesh.material = mesh.userData.highlightFloorMat;
                }

                // 计算聚焦位置
                const meshPos = mesh.position.clone();
                
                // 如果是整栋模式，计算建筑中心点
                if (isBuildingMode) {
                    const buildingFloors = floorsRef.current.filter(f => f.userData.buildingId === targetId);
                    if (buildingFloors.length > 0) {
                        let sumY = 0;
                        buildingFloors.forEach(f => sumY += f.position.y);
                        meshPos.y = sumY / buildingFloors.length;
                    }
                }
                
                // 设置目标相机位置（在选中对象前方和上方）
                const distance = isBuildingMode ? 45 : 30;
                const height = isBuildingMode ? 25 : 18;
                
                // 计算相机到目标的方向向量
                const cameraDir = new THREE.Vector3();
                cameraDir.subVectors(cameraRef.current.position, meshPos).normalize();
                
                targetCameraPos.current.set(
                    meshPos.x + cameraDir.x * distance,
                    meshPos.y + height,
                    meshPos.z + cameraDir.z * distance
                );
                targetLookAt.current.copy(meshPos);
                
                // 标记为已选中，停止旋转
                isSelectedRef.current = true;

                const data = generateStats(targetId, mesh.userData.floorIndex, isBuildingMode);
                setSelectedData(data);
            };

            // Re-bind listener with correct closure or use ref (Using Ref approach above is cleaner but need to pass to listener)
            // Actually, simply updating the listener dependency works too but creates many re-binds.
            // Let's use the Ref approach inside the existing useEffect logic? 
            // The previous useEffect had [] deps. Let's make a new one just for the listener or use a ref for the callback.

            // Simplified: Put the listener in a separate useEffect that depends on nothing, but uses refs for state
            const onMouseDownRef = useRef((e) => { });
            onMouseDownRef.current = (event) => {
                if (event.target.closest('.glass-panel') || event.target.closest('button')) return;
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, cameraRef.current);
                const intersects = raycaster.intersectObjects(floorsRef.current);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.isFloor) {
                        handleSelectionActual(object);
                    }
                } else {
                    handleDeselect();
                }
            };

            // We need to attach the listener once, and have it call the ref
            useEffect(() => {
                const handler = (e) => onMouseDownRef.current(e);
                window.addEventListener('pointerdown', handler);
                return () => window.removeEventListener('pointerdown', handler);
            }, []);


            const handleDeselect = () => {
                floorsRef.current.forEach(f => {
                    f.material = f.userData.originalMaterial;
                });
                // 恢复旋转
                isSelectedRef.current = false;
                setSelectedData(null);
            };

            return (
                <div className="relative w-full h-screen overflow-hidden">
                    <Header />
                    <Sidebar mode={mode} setMode={setMode} />
                    <DetailPanel data={selectedData} onClose={handleDeselect} />

                    <div ref={mountRef} className="absolute top-0 left-0 w-full h-full z-0 cursor-crosshair bg-slate-950" />

                    {/* Floating Toast */}
                    {!selectedData && (
                        <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 pointer-events-none">
                            <div className="bg-slate-900/80 text-emerald-100 px-5 py-2 rounded-full border border-emerald-500/30 backdrop-blur-md flex items-center gap-3 shadow-lg shadow-emerald-500/10">
                                <i data-lucide="scan-line" size={16} className="text-emerald-400"></i>
                                <span className="text-xs font-medium tracking-wide">
                                    {mode === 'floor' ? '单击楼层查看能耗详情' : '单击建筑查看整栋碳排数据'}
                                </span>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>